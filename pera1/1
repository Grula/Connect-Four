module Lib where
-- 1. posle cu da sakrivam stvari
-- 2. srediti kod da bude ugoodan
-- 3. videti da li mogu vrednosti da budu -1 1 0, jer je pogodnoo za fold
import qualified Data.Vector as V
import qualified Data.Matrix as M
import qualified Data.Maybe as Mb
data Item = Blue | Red | U deriving (Show, Eq)

--konstrukcija matrice

matrica ::Int-> M.Matrix Item

matrica n = M.matrix n n $ \(i,j)->elem
            where elem=U

-- postavi (i, j) element na elem
set i j elem mat = M.setElem elem (i,j) mat


-- data je kolona treba postaviti na  prvu undef vrednost dati element

sample = set 3 3 Blue $ set 4 3 Blue $ set 5 3 Blue $ set 6 3 Blue $ set 6 2 Red $ set 6 4 Red $ matrica 6




-- za ove funkcije treba obraditi slucajeve ako se unese neispravan indeks
setFirstFree r mat=
  let vec = M.getCol r mat
      list = V.toList vec
     -- mlastU = (V.findIndex (\e -> e /= U)) - 1 vec --indeksiranje u vektoru krece od 0
      --last = Mb.fromMaybe -1 mlastU

   in mat
-- grreska je sto on ne prepoznaje da je ovo Int



-- za datu poziciju i, j i datu matricu proveriti da li se nalaze 4 spojene, dijagonaln vertikalno i horizontalno


-- funkcija koja mapira matricu
-- Red -> -1
-- Blue -> 1
-- U -> 0

-- treba namapirati celo sranje
slika :: Item -> Int
slika e = case e of
            Red -> -1
            Blue -> 1
            U -> 0


-- rekurzina funkcija koja mapira celu matricu

mapTable mat = let n = ncols mat
                in if


someFunc :: IO ()
someFunc = putStrLn "someFunc"
